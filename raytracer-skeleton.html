<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<title>Raytracer</title>
</head>
<body>
<canvas id='my-canvas'><canvas>

<script src='vector3.js'></script>
<script src='ray.js'></script>
<script src='sphere.js'></script>
<script src='plane.js'></script>
<script>

// Canvas setup, don't need to touch any of this *******************************
// Get a reference to the javascript object associated with the canvas
var canvas = document.getElementById('my-canvas');

// The canvas dimension we will set
var pixelsAcross = 256;  // pixels across 
var pixelsDown = 256; // pixels down 

// Set dimensions and pixel scale (don't worry about pixel scale, it won't affect your maths)
var pixelScale = 3;
canvas.width = pixelsAcross;
canvas.height = pixelsDown;
canvas.style.cssText = 'width:' + (pixelsAcross * pixelScale) + 'px;height:' + (pixelsDown * pixelScale) + 'px';

// Get the context from the canvas (in this case we just want 2d)
var canvasContext = canvas.getContext('2d');

// Get an array representing all of the pixels
// Arranged left to right, top to bottom
var imageData = canvasContext.getImageData(0, 0, pixelsAcross, pixelsDown);
// end canvas setup ************************************************************


// Raytracer setup
var fov = 45;   // if this changes, your code should still work
var fovRadians = fov * 3.1415 / 180; // todo -> convert degrees to radians

var pixelWidth = pixelsAcross / 100; // todo -> what's the size of a pixel from left to right?
var pixelHalfWidth = pixelWidth / 2; // todo -> half of the pixel width

// How far away (scalar) the eye is from the image plane (see MV3202 guide for more info)
// GABE NOTE !  this evaluates to 3.09, I believe this is correct, but a second set of eyes would be good
var eyeDistance = pixelHalfWidth / Math.tan(fovRadians / 2); // = todo -> hint: related to tangent and field of view (see slides)
// -----------
// |         /
// |        /
// |       /
// | 45/2 /      <---- half angle
// |     /
// |    /
// |   /
// |  /
// | /

// important vectors
var eyeCoordinate = new Vector3(0, 0, eyeDistance); // all of your rays will use this

// these can be convenient (up to you whether you want to use them)
var right = new Vector3(1, 0, 0);
var up = new Vector3(0, 1, 0);

// Define the scene objects here ------------------

// These are 3d definitions that match all of the math we did in class
// They also provide a "raycast" function that you can pass a ray to
// in order to find intersection between the ray and the object
var purple = new Vector3(0.5, 0, 1);
var cyan = new Vector3(0, 1, 1);
var sphereSize = 2.0;
var sphereLocation = new Vector3(8, sphereSize/2, sphereSize); // Back from camera, up and down, left and right
var sphere = new Sphere(sphereLocation, sphereSize, purple,1); // todo = new Sphere(..., ...);
var plane = new Plane(new Vector3(0, -1, 1), new Vector3(0, 1, 0), cyan, 1); // todo = new Plane(..., ...);


// end of raytracer setup ******************************************************

// -----------------------------------------------------------------------------
// return a ray that goes from the eye point through the pixel at index (xPixelIndex, yPixelIndex)
function generateRayForPixel(xPixelIndex, yPixelIndex) {

   // GABE NOTE I am not certain if these need to scale as a percent of the total width /height
   var u = xPixelIndex-pixelsAcross/2;  //Needs to by symetrical around origin 0,0
   var v = yPixelIndex-pixelsDown/2; //Needs to by symetrical around origin 0,0
   var z = 0;//eyeDistance;                //Distance behind the screen ( GABE Note eye distance or zero)
   // The pixel coordinate is the location of the 
   var pixelCoordinate = new Vector3(u, v, z); // = todo: calculate pixel position   
   var direction = pixelCoordinate.subtract(eyeCoordinate); // = vector from the eye to the pixel
   
   /* Gabe Note originally I normalized the coords, however, that created an extream fisheye view
   var z = 0;                //Distance behind the screen
   var pixelCoordinate = new Vector3(u, v, z); // = todo: calculate pixel position   
   var direction = pixelCoordinate.subtract(eyeCoordinate); // = vector from the eye to the pixel
   pixelCoordinate.normalize();
   var t = eyeCoordinate.clone();
   var direction = pixelCoordinate.subtract(t.normalize()); // = vector from the eye to the pixel
   */
   //console.debug(" X: ", xPixelIndex, " Y: ", yPixelIndex, "DX:", direction.x, "DY:", direction.y, "DZ:", direction.z)


	// Creates a ray that will automatically normalize the direction
	// Uncomment this (the ray line of code) once you've calculated the pixelCoordinate in space and the
	// direction from the eye to the pixelCoordinate
	var pixelRay = new Ray(eyeCoordinate, direction);
	return pixelRay;
}

// -----------------------------------------------------------------------------
function setPixelColor(xPixelIndex, yPixelIndex, color /* now vector */ /*[0,1]*/) {

   var componetsPerPixel = 4;
   //Every pixel we move down the number of line * the number of componets per line plus the number of pixels in the current line times the number of componets per pixel
   var index = (xPixelIndex * componetsPerPixel)+(yPixelIndex * componetsPerPixel * pixelsAcross);
   
   /* Note since color is stored as a vector in sphere, we will use xyz as RGB */
   imageData.data[index + 0] = color.x * 255;
	imageData.data[index + 1] = color.y  * 255;
   imageData.data[index + 2] = color.z * 255;
	imageData.data[index + 3] = 255;

	// feel free to delete this when you are done implementing this function
	if (index == undefined) {
		alert('need to calculate the image data index for setting pixel color');
		throw 'error';
	}
}

// -----------------------------------------------------------------------------
function updateAndRender(timeElapsed) {
   var sphereHits = 0;
   var sphereSum = 0;
	// Go through every pixel
	for (var yPixelIndex = 0; yPixelIndex < pixelsDown; ++yPixelIndex) {
		for (var xPixelIndex = 0; xPixelIndex < pixelsAcross; ++xPixelIndex) {

			// Uncomment this once you've coded generateRayForPixel
			var pixelRay = generateRayForPixel(xPixelIndex, yPixelIndex);

			// See if the ray intersects the sphere or the plane (or every object in our scene)
			// Uncomment when your sphere or plane code is ready
			var sphereResult = sphere.raycast(pixelRay);
			var planeResult = plane.raycast(pixelRay);

			var hitAnything = (sphereResult.hit || planeResult.hit);

			if (hitAnything) {
            // determine  which hit object is the closest (in case there is more than 1 hit)
            if (sphereResult.hit>planeResult.hit){
               var color = sphere.color;
            }
            else{
               var color = plane.color;
            }

            // GABE NOTE !  This is to debug only, delete before turinging in
            //Debug Color scheme Start 
            // Green is the sphere only
            // Red is plane only
            //Yellow is both sphere and plane
            if (sphereResult.hit && planeResult.hit){
               var color = new Vector3(1, 1, 0);
            }
            else if (sphereResult.hit) {
               var color = new Vector3(0, 1, 0);
               sphereSum = sphereSum + sphereResult.distance;
               sphereHits = sphereHits + 1;
            }else{
               var color = new Vector3(1, 0, 0);
            }
            //Debug Color scheme Start

				setPixelColor(xPixelIndex, yPixelIndex, color); //Added color since we have to do extra credit // middle gray
			} else {
				// we didn't hit anything, choose an appropriate backbround color
				setPixelColor(xPixelIndex, yPixelIndex, 0.1); // dark gray
			}
		}
   }
   var average = sphereSum / sphereHits;

	// Take our array of color data and give to the canvas to display
	canvasContext.putImageData(imageData, 0, 0);

	// Let the browser know it should call this function again when it's time to render
	requestAnimationFrame(updateAndRender);
}

// We are ready to render, let the browser know
requestAnimationFrame(updateAndRender);

</script>
</body>
</html>